# AI エージェント実装方針

## 1. 概要

本プロジェクトでは、小説創作を AI が支援する共創型エージェントを実装する。ユーザーは創作プロセスの各段階（プロット構成、キャラクター設計、執筆など）で特定の要素を選択し、AI エージェントに質問・提案を求めることができる。

## 2. 現在の実装状況

現在、以下のコンポーネントの実装を開始している：

- **選択可能な要素（SelectableElement）**: ユーザーがプロット項目、キャラクター、章などをチェックボックスで選択できるコンポーネント
- **Recoil による状態管理**: 選択された要素、チャット履歴、チャットパネルの表示状態などを管理するアトム

## 3. エージェント機能構成

### 3.1 選択型コンテキスト機能

- プロット、キャラクター、章、世界観の各要素にチェックボックスを設置
- 選択された要素はハイライト表示され、AI との対話コンテキストに自動的に追加される
- 複数要素の組み合わせ選択が可能（例：あるキャラクターとあるプロット項目を同時に選択）

### 3.2 AI チャットパネル

- 画面右側または下部に配置するフローティングパネル
- 選択された要素の表示領域、メッセージ入力欄、送信ボタン、履歴表示で構成
- 折りたたみ可能で、必要なときだけ表示させることができる

### 3.3 役割別 AI エージェント

以下の役割を持つ AI エージェントを実装：

1. **プロットアドバイザー**

   - 物語構造の改善提案
   - 矛盾点や弱点の指摘
   - プロット展開のアイデア提供

2. **キャラクターデザイナー**

   - キャラクター設定の深堀り
   - 性格や背景の一貫性チェック
   - キャラクター間の関係性提案

3. **文体エディター**

   - 表現や描写の改善提案
   - 文章の流れや読みやすさの向上
   - 語彙や表現の多様化

4. **世界観構築アシスタント**
   - 世界のルール・設定の一貫性確認
   - 詳細な背景設定の提案
   - 文化・歴史・地理の発展アイデア

## 4. 技術実装方針

### 4.1 フロントエンド実装

- **Recoil による状態管理**:

  - 選択された要素: `selectedElementsState`
  - チャット履歴: `aiChatHistoryState`
  - メッセージ入力: `currentMessageState`
  - AI 処理状態: `aiLoadingState`
  - チャットパネル表示: `aiChatPanelOpenState`

- **コンポーネント構成**:
  - `SelectableElement`: 選択可能な要素を表示
  - `AIChatPanel`: AI との対話インターフェース
  - `SelectedContext`: 選択された要素の表示
  - `ChatHistory`: 会話履歴の表示
  - `AIResponseRenderer`: AI からの返答を適切に表示

### 4.2 バックエンド連携

- **API ルート**:

  - `/api/ai/chat`: AI エージェントとの対話用エンドポイント
  - `/api/ai/apply`: AI 提案を選択して適用するエンドポイント

- **プロンプトエンジニアリング**:

  - システムプロンプトにエージェントの役割を定義
  - 選択された要素を JSON で整形してコンテキストに含める
  - ユーザーメッセージと組み合わせて API リクエストを構成

- **OpenAI/Claude API 活用**:
  - 選択された役割に応じた適切なシステムプロンプトを設定
  - Function Calling を活用して構造化された提案を生成
  - ストリーミングレスポンスで即時表示

### 4.3 UI/UX 設計

- **チェックボックス連携**:

  - 各要素にチェックボックスを追加し、視覚的に選択状態を表示
  - 選択状態に合わせて背景色やボーダーを変更

- **チャットパネル挙動**:

  - 最初は折りたたまれた状態
  - 要素選択時に自動展開のオプション
  - ドラッグ可能な位置調整

- **レスポンシブ対応**:
  - モバイル表示時はフルスクリーンモーダルとして表示
  - デスクトップではサイドパネルとして表示

## 5. 実装ロードマップ

### フェーズ 1: 基本機能実装

- ✅ 選択可能な要素コンポーネント実装
- ✅ Recoil 状態管理設定
- AI チャットパネル実装
- 選択コンテキスト表示機能

### フェーズ 2: AI 連携機能

- OpenAI/Claude API 連携
- プロンプト設計
- レスポンス処理・表示

### フェーズ 3: 拡張機能

- 複数役割エージェント切り替え
- 提案適用機能
- 会話履歴保存・検索

### フェーズ 4: 改善・最適化

- UX 改善
- プロンプト最適化
- パフォーマンス向上

## 6. 課題と対応策

### 6.1 API 利用コスト

- **課題**: API コールが増加するとコストが増大
- **対策**:
  - キャッシュ機構の実装
  - 類似質問の検出と再利用
  - トークン数最適化

### 6.2 ユーザー体験

- **課題**: 複雑な選択肢や機能が混乱を招く可能性
- **対策**:
  - 段階的な機能導入
  - チュートリアル実装
  - 簡潔な UI デザイン

### 6.3 プロンプト設計

- **課題**: 効果的なレスポンスを引き出すプロンプト設計
- **対策**:
  - プロンプトの A/B テスト
  - フィードバックに基づく継続的改善
  - ドメイン特化テンプレート開発

## 7. 将来的な拡張計画

- **マルチモーダル対応**: 画像生成との連携（キャラクターイメージなど）
- **協調型エージェント**: 複数エージェント間での議論機能
- **学習機能**: ユーザー好みの学習と適応
- **執筆スタイル分析**: ユーザーの文体を分析し、それに合わせた提案

## 8. 実装アプローチの比較分析

AI エージェント実装のためには複数のアプローチが考えられる。以下に主要なアプローチを比較分析し、本プロジェクトにおける最適な選択肢を検討する。

### 8.1 カスタム実装（独自開発）

**メリット**:

- 要件に完全に合致したカスタマイズが可能
- サードパーティ依存がないため長期的な安定性が確保できる
- パフォーマンスを最適化しやすい

**デメリット**:

- 開発工数が大きい
- エージェント機能の実装に専門知識が必要
- メンテナンスコストが高い

### 8.2 LangChain ベースの実装

**メリット**:

- エージェント機能の実装が容易
- 豊富なコンポーネントとインテグレーション
- 活発なコミュニティサポート

**デメリット**:

- ライブラリの頻繁な更新による Breaking Changes
- 柔軟性に制限がある場合がある
- オーバーヘッドが大きくなる可能性

### 8.3 Dify のようなノーコードツール

**メリット**:

- 開発速度が非常に速い
- 技術的な障壁が低く、非エンジニアも参加可能
- ビジュアルインターフェースによる直感的な開発

**デメリット**:

- カスタマイズ性に制限がある
- 複雑なロジックの実装が難しい
- プラットフォーム依存のリスク

### 8.4 AutoGen や CrewAI のような専用エージェントフレームワーク

**メリット**:

- エージェント間協調に特化した機能
- 役割ベースのエージェント設計をサポート
- マルチステップの推論や計画立案に強み

**デメリット**:

- 比較的新しいフレームワークで安定性に懸念
- 学習曲線が急
- 特定のユースケースに最適化されている場合がある

### 8.5 クラウドサービス（Bedrock Agent や Azure AI Agent）

**メリット**:

- スケーラビリティが高い
- インフラ管理の負担が少ない
- セキュリティやコンプライアンス対応が容易

**デメリット**:

- コストが高くなる可能性
- ベンダーロックインのリスク
- カスタマイズ性に制限

## 9. 推奨アプローチ

本プロジェクトの現状と要件を考慮し、以下の**ハイブリッドアプローチ**を推奨する：

1. **基本フレームワーク**: React + TypeScript + Recoil による独自実装をベースとする

2. **エージェント機能**: LLM API を直接利用し、Function Calling を活用した軽量なエージェント機能を実装

   - 理由: 最も柔軟性が高く、本プロジェクト固有の要件に対応しやすい
   - サードパーティ依存を最小限に抑え、長期的な安定性を確保

3. **プロトタイピング**: 初期検証段階では Dify などのノーコードツールを活用し、素早く概念実証を行う

   - UI や UX の検証を効率的に行い、本実装へのインサイトを得る

4. **特定機能の補完**: 必要に応じて LangChain や LangGraph の特定モジュールを活用

   - 例: 複雑なワークフロー管理や RAG 機能など

5. **将来展望**: 協調型エージェント機能の拡張時には AutoGen などの専用フレームワークの採用を検討

このハイブリッドアプローチにより、開発効率とカスタマイズ性のバランスを取りながら、将来的な拡張性も確保することができる。また、特定のフレームワークやサービスへの過度な依存を避けることで、技術的負債のリスクを軽減できる。

## 10. LLM API 通信方法の比較分析

AI エージェントと LLM API（OpenAI、Claude 等）の通信方法について、複数のアプローチを比較検討し、本プロジェクトに最適な方法を選定する。

### 10.1 フロントエンドでの API キー管理と直接通信

**メリット**:

- 実装が最も簡単で迅速に開発可能
- バックエンド開発やインフラストラクチャが不要
- ユーザー固有の API キーを使用するため、ユーザー間で使用量が分離される

**デメリット**:

- **重大なセキュリティリスク**: クライアントサイドのコードから API キーが漏洩する可能性が高い
- ネットワークリクエストから API キーが漏洩する可能性がある
- 使用量の制限やモニタリングが難しい
- ブラウザの同一オリジンポリシーによる CORS 問題が発生する可能性がある

### 10.2 バックエンドプロキシを利用した通信

**メリット**:

- API キーをサーバーサイドで保護できる
- リクエストの検証、フィルタリング、ログ記録が可能
- 使用量の制限やモニタリングが容易
- キャッシュ機能を実装して API コスト削減が可能

**デメリット**:

- バックエンドサーバーの実装と維持が必要
- すべてのユーザーが同じ API キーを共有する場合、コスト管理が複雑になる
- サーバーのスケーリングが必要になる場合がある

### 10.3 ハイブリッドアプローチ (バックエンドプロキシ + ユーザー固有 API キー)

**メリット**:

- ユーザー固有の API キーを使用しながらもセキュリティ対策が可能
- バックエンドで API キーを検証してから転送できる
- 使用量の制限やモニタリングが容易
- ユーザーごとの使用量を分離・管理できる

**デメリット**:

- 実装が複雑になる
- バックエンドサーバーの実装と維持が必要
- ユーザーに API キーの取得と管理を要求する

### 10.4 クラウドサービスを利用した管理 (AWS Lambda + API Gateway など)

**メリット**:

- サーバーレスでスケーリングが自動化される
- セキュリティ対策が組み込まれている
- 使用量に応じた課金で運用コストを最適化できる
- クラウドサービスのセキュリティ機能を活用できる

**デメリット**:

- クラウドサービスの知識と経験が必要
- ベンダーロックインのリスク
- 設定の複雑さが増す可能性がある

### 10.5 Edge Functions (Cloudflare Workers、Vercel Edge Functions など)

**メリット**:

- グローバルに分散したエッジで実行されるため高速
- シンプルな実装で API キーの保護が可能
- サーバーレスで管理の負担が少ない
- コスト効率が良い

**デメリット**:

- 実行環境に制限がある場合がある
- 複雑なロジックの実装が難しい場合がある
- サービス依存のリスク

## 11. API 通信の推奨アプローチ

現在の要件と状況を考慮し、**バックエンドプロキシを利用した通信方法**を推奨する。理由は以下の通り：

1. **セキュリティの確保**: ユーザーの API キーをフロントエンドで直接扱うことは重大なセキュリティリスクがある。バックエンドプロキシを使用することで、API キーを安全に管理できる。

2. **柔軟な拡張性**: 将来的に認証機能や使用量の制限などを追加する場合にも対応しやすくなる。

3. **実装のシンプルさ**: 小規模な Express サーバーなどで簡単に実装でき、メンテナンスコストも比較的低く抑えられる。

### 11.1 具体的な実装例

```javascript
// バックエンドのExpressサーバー例
const express = require("express");
const cors = require("cors");
const axios = require("axios");
const app = express();

app.use(cors());
app.use(express.json());

app.post("/api/llm", async (req, res) => {
  try {
    const { apiKey, prompt, ...otherParams } = req.body;

    // APIキーの検証
    if (!apiKey || typeof apiKey !== "string") {
      return res.status(400).json({ error: "APIキーが必要です" });
    }

    // LLM APIへのリクエスト
    const response = await axios.post(
      "https://api.openai.com/v1/completions",
      {
        prompt,
        ...otherParams,
      },
      {
        headers: {
          Authorization: `Bearer ${apiKey}`,
          "Content-Type": "application/json",
        },
      }
    );

    // レスポンスの返却
    res.json(response.data);
  } catch (error) {
    console.error("Error calling LLM API:", error);
    res.status(500).json({
      error: "LLM APIの呼び出し中にエラーが発生しました",
      details: error.response?.data || error.message,
    });
  }
});

const PORT = process.env.PORT || 3001;
app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});
```

### 11.2 将来的な強化策

将来的にセキュリティや機能を強化する場合は、以下の対策も検討する：

1. **一時的なトークン発行**: API キーを直接使用する代わりに、限定的な権限と有効期限を持つ一時的なトークンを発行する仕組みを実装

2. **使用量制限**: ユーザーごとにリクエスト数や使用量を制限する機能を追加

3. **キャッシュ機能**: 同じリクエストに対する応答をキャッシュして、API 呼び出しのコストを削減

4. **認証機能**: 必要に応じてユーザー認証を実装し、認証されたユーザーのみが API を利用できるようにする

この方法であれば、ログイン機能を実装しなくてもセキュアに API キーを扱うことができる。

## 12. データベース導入に関する検討

本プロジェクトでは、現時点においてデータベース（DB）の導入は不要と判断している。以下にその理由と将来的な検討事項を示す。

### 12.1 データベース不要の理由

1. **ユーザーデータの管理方針**:

   - ユーザー作成コンテンツ（プロジェクト、プロット、キャラクターなど）はエクスポート機能を提供し、ユーザー自身がローカルに保存
   - 必要に応じてファイルをインポートし、作業を再開できる仕組みを提供
   - サーバー側でのデータ永続化は行わない設計

2. **シンプルな実装アプローチ**:

   - データ保存機能を盛り込まないことで、バックエンド実装を最小限に抑制
   - セキュリティやプライバシーに関するリスクを低減
   - メンテナンスコストの削減

3. **オフライン作業のサポート**:
   - インターネット接続がない環境でも基本機能が利用可能
   - ユーザーがデータの管理権限を完全に保持

### 12.2 データベースなしでの実装方法

1. **ローカルストレージの活用**:

   - ブラウザのローカルストレージまたは IndexedDB を使用した一時的なデータ保存
   - セッション間での作業状態の維持
   - エクスポート/インポート機能との連携

2. **ファイルベースのデータ交換**:

   - JSON 形式でのプロジェクトデータのエクスポート
   - インポート機能による作業再開
   - バージョン管理のためのメタデータ付与

3. **AI 会話履歴の管理**:
   - セッション内でのみ会話履歴を保持
   - 必要に応じてエクスポートファイルに含める選択肢を提供

### 12.3 将来的な拡張可能性

将来的な機能拡張によってはデータベース導入が検討される可能性がある。以下のような場合に再検討を行う：

1. **ユーザー認証機能の追加**:

   - ユーザーアカウント管理が必要になった場合
   - 複数デバイス間でのデータ同期機能を実装する場合

2. **協調機能の実装**:

   - 複数ユーザーによる共同編集機能を追加する場合
   - 共有プロジェクトやテンプレートライブラリを実装する場合

3. **高度な分析機能**:

   - ユーザーの使用パターンを分析して AI の提案を改善する場合
   - 匿名化された事例集や知識ベースを構築する場合

4. **有料プラン導入**:
   - 課金システムを導入し、利用量に応じた料金体系を実装する場合

現時点では、シンプルさとユーザー自身によるデータ管理の透明性を優先し、データベース不要のアプローチを採用する。これにより、開発コストの低減とプライバシー保護の両立を図る。
